import { useState, useCallback } from 'react';
import type { Session, Command } from '../api/types.gen';
import type { ConnectionContextType } from '../contexts/ConnectionContext';
import type { CommandSuggestion } from '../utils/commandMentions';
import { sessionCommand, sessionInit, sessionShare, sessionUnshare, sessionSummarize, sessionUnrevert, sessionCreate } from '../api/sdk.gen';
import type { BuiltInCommand } from '../types/commands';

export interface CommandExecutionHook {
  commandStatus: string | null;
  handleCommandExecution: (commandText: string) => void;
  handleCommandSelect: (command: CommandSuggestion) => void;
  handleMenuCommandSelect: (command: BuiltInCommand | Command) => void;
}

export function useCommandExecution(
  connection: ConnectionContextType,
  currentSession: Session | null,
  currentModel: { providerID: string; modelID: string } | null,
  loadMessages: (sessionId: string) => Promise<void>
): CommandExecutionHook {
  const {
    client,
    addSessionOptimistically
  } = connection;
  
  const [commandStatus, setCommandStatus] = useState<string | null>(null);

  const handleCommandExecution = useCallback((commandText: string) => {
    if (!currentSession || !client) {
      return;
    }

    // Extract command name and arguments
    const trimmedCommandText = commandText.trim();
    let commandName = '';
    let args = '';

    // Check if there's a space to separate command from arguments
    const spaceIndex = trimmedCommandText.indexOf(' ');
    if (spaceIndex === -1) {
      // No arguments provided
      commandName = trimmedCommandText.slice(1); // Remove leading /
    } else {
      // Arguments provided
      commandName = trimmedCommandText.slice(1, spaceIndex); // Remove leading / and get command name
      args = trimmedCommandText.slice(spaceIndex + 1); // Get everything after the space
    }

    console.log('Executing command:', { command: commandName, args, currentModel });

    // Execute command asynchronously without blocking the UI
    const executeAsync = async () => {
      try {
        const commandBody: {
          messageID?: string;
          agent?: string;
          model?: string;
          arguments: string;
          command: string;
        } = {
          command: commandName,
          arguments: args
        };

        // Include current model information if available
        if (currentModel?.providerID && currentModel?.modelID) {
          commandBody.model = `${currentModel.providerID}/${currentModel.modelID}`;
        }

        await sessionCommand({
          client,
          path: { id: currentSession.id },
          body: commandBody
        });
        console.log('Command executed successfully');
      } catch (error) {
        console.error('Failed to execute command:', error);
      }
    };

    // Start execution without awaiting - this makes it asynchronous
    executeAsync();
  }, [client, currentSession, currentModel]);

  const handleCommandSelect = useCallback((command: CommandSuggestion) => {
    console.log('Command selected:', command);
    // Check if the command template contains $ARGUMENTS
    if (command.template && command.template.includes('$ARGUMENTS')) {
      // For commands with $ARGUMENTS, we just insert the command name and let the user type arguments
      // The command will be sent when the user presses send
      console.log('Command requires arguments, inserting into input');
      // Note: This should update the input text in the parent component
    } else {
      // For commands without $ARGUMENTS, execute immediately (asynchronously)
      const commandText = `/${command.name}`;
      handleCommandExecution(commandText);
    }
  }, [handleCommandExecution]);

  const handleMenuCommandSelect = useCallback(async (command: BuiltInCommand | Command) => {
    console.log('Menu command selected:', command);
    
    if (!currentSession || !client) {
      return;
    }

    // Check if it's a built-in command
    if ('endpoint' in command) {
      const builtInCommand = command as BuiltInCommand;

      try {
        // Set initial status message
        setCommandStatus(`Running ${builtInCommand.name}...`);

        switch (builtInCommand.endpoint) {
          case 'init':
            if (!currentModel?.providerID || !currentModel?.modelID) {
              setCommandStatus(null);
              return;
            }
            await sessionInit({
              client,
              path: { id: currentSession.id },
              body: {
                messageID: '', // Will be generated by the server
                providerID: currentModel.providerID,
                modelID: currentModel.modelID,
              }
            });
            setCommandStatus('AGENTS.md created successfully');
            // Clear status after 3 seconds
            setTimeout(() => setCommandStatus(null), 3000);
            break;
          
          case 'share':
            const shareResponse = await sessionShare({
              client,
              path: { id: currentSession.id }
            });
            // Extract session URL from response
            if (shareResponse.data?.share?.url) {
              setCommandStatus('Session shared successfully');
            } else {
              setCommandStatus('Session shared (URL not available)');
            }
            // Clear status after 5 seconds
            setTimeout(() => setCommandStatus(null), 5000);
            break;
          
          case 'unshare':
            await sessionUnshare({
              client,
              path: { id: currentSession.id }
            });
            setCommandStatus('Session unshared successfully');
            setTimeout(() => setCommandStatus(null), 3000);
            break;
          
          case 'summarize':
            if (!currentModel?.providerID || !currentModel?.modelID) {
              setCommandStatus(null);
              return;
            }
            await sessionSummarize({
              client,
              path: { id: currentSession.id },
              body: {
                providerID: currentModel.providerID,
                modelID: currentModel.modelID,
              }
            });
            setCommandStatus('Session summarized successfully');
            setTimeout(() => setCommandStatus(null), 3000);
            break;
          
          case 'revert':
            // For revert, we need access to messages to get the last message ID
            // This should be handled by the parent component or we need to pass messages here
            setCommandStatus('Revert not implemented in this hook');
            setTimeout(() => setCommandStatus(null), 3000);
            break;
          
          case 'unrevert':
            await sessionUnrevert({
              client,
              path: { id: currentSession.id }
            });
            // Reload messages since redo rewrites history
            await loadMessages(currentSession.id);
            setCommandStatus('Message restored successfully');
            setTimeout(() => setCommandStatus(null), 3000);
            break;
          
          case 'new':
            // Create a new chat session
            if (connection.connectionStatus !== 'connected' || !client) {
              setCommandStatus('No connection available');
              setTimeout(() => setCommandStatus(null), 3000);
              return;
            }
            
            try {
              console.log('Creating new session from command menu...');
              const response = await sessionCreate({ client });

              if (response.error) {
                console.error('Session creation error:', response.error);
                throw new Error(`Failed to create session: ${JSON.stringify(response.error)}`);
              }

              if (response.data) {
                const newSession = response.data;
                console.log('New session created:', newSession.id, newSession.title);

                // Optimistically add the session to local state
                addSessionOptimistically(newSession);

                setCommandStatus('New chat created successfully');
                setTimeout(() => setCommandStatus(null), 3000);
              }
            } catch (error) {
              console.error('Error creating session:', error);
              setCommandStatus('Failed to create new chat');
              setTimeout(() => setCommandStatus(null), 3000);
            }
            break;
          
          default:
            console.warn('Unknown built-in command endpoint:', builtInCommand.endpoint);
            return;
        }
        
        console.log(`Built-in command ${builtInCommand.name} executed successfully`);
        
      } catch (error) {
        console.error(`Failed to execute built-in command ${builtInCommand.name}:`, error);
        setCommandStatus(`Failed to ${builtInCommand.name}`);
        setTimeout(() => setCommandStatus(null), 3000);
      }
    } else {
      // It's a user command, execute via the existing command system
      const userCommand = command as Command;
      const commandText = `/${userCommand.name}`;
      handleCommandExecution(commandText);
    }
  }, [currentSession, client, currentModel, handleCommandExecution, loadMessages, connection.connectionStatus, addSessionOptimistically]);

  return {
    commandStatus,
    handleCommandExecution,
    handleCommandSelect,
    handleMenuCommandSelect
  };
}